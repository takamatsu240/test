"use strict";
// Copyright 2026 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.PipelineResult = exports.PipelineSnapshot = exports.ExplainStats = exports.Pipeline = exports.PipelineSource = void 0;
const deepEqual = require("fast-deep-equal");
const index_1 = require("../index");
const path_1 = require("../path");
const pipeline_util_1 = require("./pipeline-util");
const document_reference_1 = require("../reference/document-reference");
const serializer_1 = require("../serializer");
const util_1 = require("../util");
const expression_1 = require("./expression");
const stage_1 = require("./stage");
const structured_pipeline_1 = require("./structured-pipeline");
const protobufjs_1 = require("protobufjs");
/**
 * @beta
 * Represents the source of a Firestore `Pipeline`.
 */
class PipelineSource {
    db;
    constructor(db) {
        this.db = db;
    }
    collection(collectionOrOptions) {
        const options = (0, pipeline_util_1.isString)(collectionOrOptions) ||
            (0, pipeline_util_1.isCollectionReference)(collectionOrOptions)
            ? {}
            : collectionOrOptions;
        const collection = (0, pipeline_util_1.isString)(collectionOrOptions) ||
            (0, pipeline_util_1.isCollectionReference)(collectionOrOptions)
            ? collectionOrOptions
            : collectionOrOptions.collection;
        // Validate that a user provided reference is for the same Firestore DB
        if ((0, pipeline_util_1.isCollectionReference)(collection)) {
            this._validateReference(collection);
        }
        const normalizedCollection = (0, pipeline_util_1.isString)(collection)
            ? this.db.collection(collection)
            : collection;
        const internalOptions = {
            ...options,
            collection: normalizedCollection,
        };
        return new Pipeline(this.db, [new stage_1.CollectionSource(internalOptions)]);
    }
    collectionGroup(collectionIdOrOptions) {
        const options = (0, pipeline_util_1.isString)(collectionIdOrOptions)
            ? { collectionId: collectionIdOrOptions }
            : { ...collectionIdOrOptions };
        return new Pipeline(this.db, [new stage_1.CollectionGroupSource(options)]);
    }
    database(options) {
        return new Pipeline(this.db, [new stage_1.DatabaseSource(options ?? {})]);
    }
    documents(docsOrOptions) {
        const options = Array.isArray(docsOrOptions) ? {} : docsOrOptions;
        const docs = Array.isArray(docsOrOptions)
            ? docsOrOptions
            : docsOrOptions.docs;
        // Validate that all user provided references are for the same Firestore DB
        docs
            .filter(v => v instanceof document_reference_1.DocumentReference)
            .forEach(dr => this._validateReference(dr));
        const normalizedDocs = docs.map(doc => (0, pipeline_util_1.isString)(doc) ? this.db.doc(doc) : doc);
        const internalOptions = {
            ...options,
            docs: normalizedDocs,
        };
        return new Pipeline(this.db, [new stage_1.DocumentsSource(internalOptions)]);
    }
    createFrom(query) {
        return query._pipeline();
    }
    _validateReference(reference) {
        if (!(reference instanceof index_1.CollectionReference ||
            reference instanceof document_reference_1.DocumentReference)) {
            throw new Error('Invalid reference. The value may not be a CollectionReference or DocumentReference. Or, it may be an object from a different SDK build.');
        }
        const refDbId = reference.firestore.formattedName;
        if (refDbId !== this.db.formattedName) {
            throw new Error(`Invalid ${reference instanceof index_1.CollectionReference
                ? 'CollectionReference'
                : 'DocumentReference'}. ` +
                `The database name ("${refDbId}") of this reference does not match ` +
                `the database name ("${this.db.formattedName}") of the target database of this Pipeline.`);
        }
        return true;
    }
}
exports.PipelineSource = PipelineSource;
/**
 * @beta
 * The Pipeline class provides a flexible and expressive framework for building complex data
 * transformation and query pipelines for Firestore.
 *
 * A pipeline takes data sources, such as Firestore collections or collection groups, and applies
 * a series of stages that are chained together. Each stage takes the output from the previous stage
 * (or the data source) and produces an output for the next stage (or as the final output of the
 * pipeline).
 *
 * Expressions can be used within each stage to filter and transform data through the stage.
 *
 * NOTE: The chained stages do not prescribe exactly how Firestore will execute the pipeline.
 * Instead, Firestore only guarantees that the result is the same as if the chained stages were
 * executed in order.
 *
 * Usage Examples:
 *
 * @example
 * ```typescript
 * const db: Firestore; // Assumes a valid firestore instance.
 *
 * // Example 1: Select specific fields and rename 'rating' to 'bookRating'
 * const results1 = await db.pipeline()
 *     .collection('books')
 *     .select('title', 'author', field('rating').as('bookRating'))
 *     .execute();
 *
 * // Example 2: Filter documents where 'genre' is 'Science Fiction' and 'published' is after 1950
 * const results2 = await db.pipeline()
 *     .collection('books')
 *     .where(and(field('genre').equal('Science Fiction'), field('published').greaterThan(1950)))
 *     .execute();
 *
 * // Example 3: Calculate the average rating of books published after 1980
 * const results3 = await db.pipeline()
 *     .collection('books')
 *     .where(field('published').greaterThan(1980))
 *     .aggregate(average(field('rating')).as('averageRating'))
 *     .execute();
 * ```
 */
class Pipeline {
    db;
    stages;
    constructor(db, stages) {
        this.db = db;
        this.stages = stages;
    }
    _addStage(stage) {
        const copy = this.stages.map(s => s);
        copy.push(stage);
        return new Pipeline(this.db, copy);
    }
    addFields(fieldOrOptions, ...additionalFields) {
        const options = (0, pipeline_util_1.isSelectable)(fieldOrOptions) ? {} : fieldOrOptions;
        const fields = (0, pipeline_util_1.isSelectable)(fieldOrOptions)
            ? [fieldOrOptions, ...additionalFields]
            : fieldOrOptions.fields;
        const normalizedFields = (0, pipeline_util_1.selectablesToMap)(fields);
        this._validateUserData('select', normalizedFields);
        const internalOptions = {
            ...options,
            fields: normalizedFields,
        };
        return this._addStage(new stage_1.AddFields(internalOptions));
    }
    removeFields(fieldValueOrOptions, ...additionalFields) {
        const options = (0, pipeline_util_1.isField)(fieldValueOrOptions) || (0, pipeline_util_1.isString)(fieldValueOrOptions)
            ? {}
            : fieldValueOrOptions;
        const fields = (0, pipeline_util_1.isField)(fieldValueOrOptions) || (0, pipeline_util_1.isString)(fieldValueOrOptions)
            ? [fieldValueOrOptions, ...additionalFields]
            : fieldValueOrOptions.fields;
        const convertedFields = fields.map(f => (0, pipeline_util_1.isString)(f) ? (0, expression_1.field)(f) : f);
        this._validateUserData('removeFields', convertedFields);
        const innerOptions = {
            ...options,
            fields: convertedFields,
        };
        return this._addStage(new stage_1.RemoveFields(innerOptions));
    }
    select(selectionOrOptions, ...additionalSelections) {
        const options = (0, pipeline_util_1.isSelectable)(selectionOrOptions) || (0, pipeline_util_1.isString)(selectionOrOptions)
            ? {}
            : selectionOrOptions;
        const selections = (0, pipeline_util_1.isSelectable)(selectionOrOptions) || (0, pipeline_util_1.isString)(selectionOrOptions)
            ? [selectionOrOptions, ...additionalSelections]
            : selectionOrOptions.selections;
        const normalizedSelections = (0, pipeline_util_1.selectablesToMap)(selections);
        this._validateUserData('select', normalizedSelections);
        const internalOptions = {
            ...options,
            selections: normalizedSelections,
        };
        return this._addStage(new stage_1.Select(internalOptions));
    }
    where(conditionOrOptions) {
        const options = (0, pipeline_util_1.isBooleanExpr)(conditionOrOptions) ? {} : conditionOrOptions;
        const condition = (0, pipeline_util_1.isBooleanExpr)(conditionOrOptions)
            ? conditionOrOptions
            : conditionOrOptions.condition;
        const convertedCondition = condition;
        this._validateUserData('where', convertedCondition);
        const internalOptions = {
            ...options,
            condition: convertedCondition,
        };
        return this._addStage(new stage_1.Where(internalOptions));
    }
    offset(offsetOrOptions) {
        const options = (0, pipeline_util_1.isNumber)(offsetOrOptions) ? {} : offsetOrOptions;
        const offset = (0, pipeline_util_1.isNumber)(offsetOrOptions)
            ? offsetOrOptions
            : offsetOrOptions.offset;
        const internalOptions = {
            ...options,
            offset,
        };
        return this._addStage(new stage_1.Offset(internalOptions));
    }
    limit(limitOrOptions) {
        const options = (0, pipeline_util_1.isNumber)(limitOrOptions) ? {} : limitOrOptions;
        const limit = (0, pipeline_util_1.isNumber)(limitOrOptions)
            ? limitOrOptions
            : limitOrOptions.limit;
        const internalOptions = {
            ...options,
            limit,
        };
        return this._addStage(new stage_1.Limit(internalOptions));
    }
    distinct(groupOrOptions, ...additionalGroups) {
        const options = (0, pipeline_util_1.isString)(groupOrOptions) || (0, pipeline_util_1.isSelectable)(groupOrOptions)
            ? {}
            : groupOrOptions;
        const groups = (0, pipeline_util_1.isString)(groupOrOptions) || (0, pipeline_util_1.isSelectable)(groupOrOptions)
            ? [groupOrOptions, ...additionalGroups]
            : groupOrOptions.groups;
        const convertedGroups = (0, pipeline_util_1.selectablesToMap)(groups);
        this._validateUserData('distinct', convertedGroups);
        const internalOptions = {
            ...options,
            groups: convertedGroups,
        };
        return this._addStage(new stage_1.Distinct(internalOptions));
    }
    aggregate(targetOrOptions, ...rest) {
        const options = (0, pipeline_util_1.isAliasedAggregate)(targetOrOptions) ? {} : targetOrOptions;
        const accumulators = (0, pipeline_util_1.isAliasedAggregate)(targetOrOptions)
            ? [targetOrOptions, ...rest]
            : targetOrOptions.accumulators;
        const convertedAccumulators = (0, pipeline_util_1.aliasedAggregateToMap)(accumulators);
        const groups = (0, pipeline_util_1.isAliasedAggregate)(targetOrOptions) ? [] : (targetOrOptions.groups ?? []);
        const convertedGroups = (0, pipeline_util_1.selectablesToMap)(groups);
        this._validateUserData('aggregate', convertedGroups);
        const internalOptions = {
            ...options,
            accumulators: convertedAccumulators,
            groups: convertedGroups,
        };
        return this._addStage(new stage_1.Aggregate(internalOptions));
    }
    /**
     * @beta
     * Performs a vector proximity search on the documents from the previous stage, returning the
     * K-nearest documents based on the specified query `vectorValue` and `distanceMeasure`. The
     * returned documents will be sorted in order from nearest to furthest from the query `vectorValue`.
     *
     *
     * @example
     * ```typescript
     * // Find the 10 most similar books based on the book description.
     * const bookDescription = "Lorem ipsum...";
     * const queryVector: number[] = ...; // compute embedding of `bookDescription`
     *
     * firestore.pipeline().collection("books")
     *     .findNearest({
     *       field: 'embedding',
     *       vectorValue: queryVector,
     *       distanceMeasure: 'euclidean',
     *       limit: 10,                        // optional
     *       distanceField: 'computedDistance' // optional
     *     });
     * ```
     *
     * @param options - An object that specifies required and optional parameters for the stage.
     * @returns A new `Pipeline` object with this stage appended to the stage list.
     */
    findNearest(options) {
        const field = (0, pipeline_util_1.toField)(options.field);
        const vectorValue = (0, pipeline_util_1.vectorToExpr)(options.vectorValue);
        const distanceField = options.distanceField
            ? (0, pipeline_util_1.toField)(options.distanceField)
            : undefined;
        this._validateUserData('findNearest', field);
        this._validateUserData('findNearest', vectorValue);
        const internalOptions = {
            ...options,
            field,
            vectorValue,
            distanceField,
        };
        return this._addStage(new stage_1.FindNearest(internalOptions));
    }
    replaceWith(valueOrOptions) {
        const options = (0, pipeline_util_1.isString)(valueOrOptions) || (0, pipeline_util_1.isExpr)(valueOrOptions) ? {} : valueOrOptions;
        const fieldNameOrExpr = (0, pipeline_util_1.isString)(valueOrOptions) || (0, pipeline_util_1.isExpr)(valueOrOptions)
            ? valueOrOptions
            : valueOrOptions.map;
        const mapExpr = (0, pipeline_util_1.fieldOrExpression)(fieldNameOrExpr);
        this._validateUserData('replaceWith', mapExpr);
        const internalOptions = {
            ...options,
            map: mapExpr,
        };
        return this._addStage(new stage_1.ReplaceWith(internalOptions));
    }
    sample(documentsOrOptions) {
        const options = (0, pipeline_util_1.isNumber)(documentsOrOptions) ? {} : documentsOrOptions;
        let rate;
        let mode;
        if ((0, pipeline_util_1.isNumber)(documentsOrOptions)) {
            rate = documentsOrOptions;
            mode = 'documents';
        }
        else if ((0, pipeline_util_1.isNumber)(documentsOrOptions.documents)) {
            rate = documentsOrOptions.documents;
            mode = 'documents';
        }
        else {
            rate = documentsOrOptions.percentage;
            mode = 'percent';
        }
        const internalOptions = {
            ...options,
            rate,
            mode,
        };
        return this._addStage(new stage_1.Sample(internalOptions));
    }
    union(otherOrOptions) {
        const options = (0, pipeline_util_1.isPipeline)(otherOrOptions) ? {} : otherOrOptions;
        const otherPipeline = (0, pipeline_util_1.isPipeline)(otherOrOptions)
            ? otherOrOptions
            : otherOrOptions.other;
        const normalizedOtherPipeline = otherPipeline;
        const internalOptions = {
            ...options,
            other: normalizedOtherPipeline,
        };
        return this._addStage(new stage_1.Union(internalOptions));
    }
    unnest(selectableOrOptions, indexField) {
        const options = (0, pipeline_util_1.isSelectable)(selectableOrOptions)
            ? {}
            : selectableOrOptions;
        const selectable = (0, pipeline_util_1.isSelectable)(selectableOrOptions)
            ? selectableOrOptions
            : selectableOrOptions.selectable;
        const alias = selectable._alias;
        const expr = selectable._expr;
        const indexFieldName = (0, pipeline_util_1.isSelectable)(selectableOrOptions)
            ? indexField
            : selectableOrOptions.indexField;
        const normalizedIndexField = indexFieldName
            ? (0, expression_1.field)(indexFieldName)
            : undefined;
        const internalOptions = {
            ...options,
            alias,
            expr,
            indexField: normalizedIndexField,
        };
        return this._addStage(new stage_1.Unnest(internalOptions));
    }
    sort(orderingOrOptions, ...additionalOrderings) {
        const options = (0, pipeline_util_1.isOrdering)(orderingOrOptions) ? {} : orderingOrOptions;
        const orderings = (0, pipeline_util_1.isOrdering)(orderingOrOptions)
            ? [orderingOrOptions, ...additionalOrderings]
            : orderingOrOptions.orderings;
        const normalizedOrderings = orderings;
        this._validateUserData('sort', normalizedOrderings);
        const internalOptions = {
            ...options,
            orderings: normalizedOrderings,
        };
        return this._addStage(new stage_1.Sort(internalOptions));
    }
    /**
     * @beta
     * Adds a raw stage to the pipeline.
     *
     * <p>This method provides a flexible way to extend the pipeline's functionality by adding custom
     * stages. Each raw stage is defined by a unique `name` and a set of `params` that control its
     * behavior.
     *
     * @example
     * Assuming there is no 'where' stage available in SDK:
     *
     * @example
     * ```typescript
     * // Assume we don't have a built-in 'where' stage
     * firestore.pipeline().collection('books')
     *     .rawStage('where', [field('published').lessThan(1900)]) // Custom 'where' stage
     *     .select('title', 'author');
     * ```
     *
     * @param name - The unique name of the raw stage to add.
     * @param params - A list of parameters to configure the raw stage's behavior.
     * @param options - An object of key value pairs that specifies optional parameters for the stage.
     * @returns A new `Pipeline` object with this stage appended to the stage list.
     */
    rawStage(name, params, options) {
        // Convert input values to Expressions.
        // We treat objects as mapValues and arrays as arrayValues,
        // this is unlike the default conversion for objects and arrays
        // passed to an expression.
        const expressionParams = params.map((value) => {
            if (value instanceof expression_1.Expression) {
                return value;
            }
            else if (value instanceof expression_1.AggregateFunction) {
                return value;
            }
            else if ((0, util_1.isPlainObject)(value)) {
                return (0, expression_1._mapValue)(value);
            }
            else {
                return (0, expression_1.constant)(value);
            }
        });
        expressionParams.forEach(param => {
            if ((0, serializer_1.hasUserData)(param)) {
                param._validateUserData(!!this.db._settings.ignoreUndefinedProperties);
            }
        });
        return this._addStage(new stage_1.RawStage(name, expressionParams, options ?? {}));
    }
    /**
     * @beta
     * Executes this pipeline and returns a Promise to represent the asynchronous operation.
     *
     * <p>The returned Promise can be used to track the progress of the pipeline execution
     * and retrieve the results (or handle any errors) asynchronously.
     *
     * <p>The pipeline results are returned in a `PipelineSnapshot` object, which contains a list of
     * `PipelineResult` objects. Each `PipelineResult` typically represents a single key/value map that
     * has passed through all the stages of the pipeline, however this might differ depending on the stages involved
     * in the pipeline. For example:
     *
     * <ul>
     *   <li>If there are no stages or only transformation stages, each `PipelineResult`
     *       represents a single document.</li>
     *   <li>If there is an aggregation, only a single `PipelineResult` is returned,
     *       representing the aggregated results over the entire dataset .</li>
     *   <li>If there is an aggregation stage with grouping, each `PipelineResult` represents a
     *       distinct group and its associated aggregated values.</li>
     * </ul>
     *
     *
     * @example
     * ```typescript
     * const futureResults = await firestore.pipeline().collection('books')
     *     .where(greaterThan(field('rating'), 4.5))
     *     .select('title', 'author', 'rating')
     *     .execute();
     * ```
     *
     * @param pipelineExecuteOptions - Optionally specify pipeline execution behavior.
     * @returns A Promise representing the asynchronous pipeline execution.
     */
    execute(pipelineExecuteOptions) {
        return this._execute(undefined, pipelineExecuteOptions).then(response => {
            const results = response.result || [];
            const executionTime = response.executionTime;
            const stats = response.explainStats;
            return new PipelineSnapshot(this, results, executionTime, stats);
        });
    }
    _execute(transactionOrReadTime, pipelineExecuteOptions) {
        const util = new pipeline_util_1.ExecutionUtil(this.db, this.db._serializer);
        const structuredPipeline = this._toStructuredPipeline(pipelineExecuteOptions);
        return util
            ._getResponse(structuredPipeline, transactionOrReadTime)
            .then(result => result);
    }
    _toStructuredPipeline(pipelineExecuteOptions) {
        const structuredPipelineOptions = pipelineExecuteOptions ?? {};
        const optionsOverride = pipelineExecuteOptions?.rawOptions ?? {};
        return new structured_pipeline_1.StructuredPipeline(this, structuredPipelineOptions, optionsOverride);
    }
    /**
     * @beta
     * Executes this pipeline and streams the results as `PipelineResult`s.
     *
     * @returns {Stream.<PipelineResult>} A stream of
     * PipelineResult.
     *
     * @example
     * ```typescript
     * firestore.pipeline().collection('books')
     *     .where(greaterThan(field('rating'), 4.5))
     *     .select('title', 'author', 'rating')
     *     .stream()
     *     .on('data', (pipelineResult) => {})
     *     .on('end', () => {});
     * ```
     */
    stream() {
        const util = new pipeline_util_1.ExecutionUtil(this.db, this.db._serializer);
        // TODO(pipelines) support options
        const structuredPipeline = this._toStructuredPipeline();
        return util.stream(structuredPipeline, undefined);
    }
    _toProto() {
        const stages = this.stages.map(stage => stage._toProto(this.db._serializer));
        return { stages };
    }
    /**
     * @beta
     * Validates user data for each expression in the expressionMap.
     * @param name Name of the calling function. Used for error messages when invalid user data is encountered.
     * @param val
     * @returns the expressionMap argument.
     * @private
     */
    _validateUserData(_, val) {
        const ignoreUndefinedProperties = !!this.db._settings.ignoreUndefinedProperties;
        if ((0, serializer_1.hasUserData)(val)) {
            val._validateUserData(ignoreUndefinedProperties);
        }
        else if (Array.isArray(val)) {
            val.forEach(readableData => {
                readableData._validateUserData(ignoreUndefinedProperties);
            });
        }
        else {
            val.forEach(expr => expr._validateUserData(ignoreUndefinedProperties));
        }
        return val;
    }
}
exports.Pipeline = Pipeline;
/**
 * @beta
 * A wrapper object to access explain stats if explain or analyze
 * was enabled for the Pipeline query execution.
 */
class ExplainStats {
    explainStatsData;
    static protoRoot = undefined;
    /**
     * @beta
     * @private
     * @internal
     */
    static async _ensureMessageTypesLoaded() {
        if (ExplainStats.protoRoot) {
            return;
        }
        this.protoRoot = await (0, protobufjs_1.load)('../protos/google/protobuf/wrappers.proto');
    }
    /**
     * @beta
     * @private
     * @internal
     * @hideconstructor
     * @param _value
     */
    constructor(explainStatsData) {
        this.explainStatsData = explainStatsData;
    }
    /**
     * @beta
     * Decode an ExplainStats proto message into a value.
     * @private
     * @internal
     * @param explainStatsMessage
     */
    _decode() {
        if (!ExplainStats.protoRoot) {
            throw new Error('Ensure message types are loaded before attempting to decode ExplainStats');
        }
        if (!this.explainStatsData.value) {
            throw new Error('Unexpected explainStatsMessage without data');
        }
        if (!this.explainStatsData.type_url) {
            throw new Error('Unexpected explainStatsMessage without type_url');
        }
        const typeUrl = this.explainStatsData.type_url;
        let reflectionObject = null;
        const NAMESPACE = 'type.googleapis.com/';
        if (!typeUrl.startsWith(NAMESPACE) ||
            !(reflectionObject = ExplainStats.protoRoot.lookup(typeUrl.slice(NAMESPACE.length))) ||
            !(reflectionObject instanceof protobufjs_1.Type)) {
            throw new Error(`Unsupported explainStatsMessage type_url "${this.explainStatsData.type_url}". Use \`.rawMessage\` to get access to the encoded explainStats message and perform the protobuf parsing in your application.`);
        }
        const messageType = reflectionObject;
        return messageType.toObject(messageType.decode(this.explainStatsData.value))
            .value;
    }
    /**
     * @beta
     * When explain stats were requested with `outputFormat = 'text'`, this returns
     * the explain stats string verbatium as returned from the Firestore backend.
     *
     * If explain stats were requested with `outputFormat = 'json'`, this returns
     * the explain stats as stringified JSON, which was returned from the Firestore backend.
     */
    get text() {
        const value = this._decode();
        if ((0, pipeline_util_1.isString)(value)) {
            return value;
        }
        throw new Error("Explain stats is not in a string format, ensure you requested an `explainOptions.outputFormat` that returns a string value, such as 'text'.");
    }
    /**
     * @beta
     * Returns the explain stats in an encoded proto format, as returned from the Firestore backend.
     * The caller is responsible for unpacking this proto message.
     */
    get rawData() {
        return this.explainStatsData;
    }
}
exports.ExplainStats = ExplainStats;
/**
 * @beta
 * Represents the results of a Firestore pipeline execution.
 *
 * A `PipelineSnapshot` contains zero or more `PipelineResult` objects
 * representing the documents returned by a pipeline query. It provides methods
 * to iterate over the documents and access metadata about the query results.
 *
 * @example
 * ```typescript
 * const snapshot: PipelineSnapshot = await firestore
 *   .pipeline()
 *   .collection('myCollection')
 *   .where(field('value').greaterThan(10))
 *   .execute();
 *
 * snapshot.results.forEach(doc => {
 *   console.log(doc.id, '=>', doc.data());
 * });
 * ```
 */
class PipelineSnapshot {
    _pipeline;
    _executionTime;
    _results;
    _explainStats;
    constructor(pipeline, results, executionTime, explainStats) {
        this._pipeline = pipeline;
        this._executionTime = executionTime;
        this._results = results;
        this._explainStats = explainStats;
    }
    /**
     * @beta
     * The Pipeline on which you called `execute()` in order to get this
     * `PipelineSnapshot`.
     */
    get pipeline() {
        return this._pipeline;
    }
    /**
     * @beta An array of all the results in the `PipelineSnapshot`. */
    get results() {
        return this._results;
    }
    /**
     * @beta
     * The time at which the pipeline producing this result is executed.
     *
     * @type {Timestamp}
     * @readonly
     *
     */
    get executionTime() {
        if (this._executionTime === undefined) {
            throw new Error("'executionTime' is expected to exist, but it is undefined");
        }
        return this._executionTime;
    }
    /**
     * @beta
     * Return stats from query explain.
     *
     * If `explainOptions.mode` was set to `execute` or left unset, then this returns `undefined`.
     */
    get explainStats() {
        return this._explainStats;
    }
}
exports.PipelineSnapshot = PipelineSnapshot;
/**
 * @beta
 * A PipelineResult contains data read from a Firestore Pipeline. The data can be extracted with the
 * `data()` or `get(String)` methods.
 *
 * <p>If the PipelineResult represents a non-document result, `ref` will return a undefined
 * value.
 */
class PipelineResult {
    _fieldsProto;
    _ref;
    _serializer;
    _executionTime;
    _createTime;
    _updateTime;
    /**
     * @beta
     * @private
     * @internal
     *
     * @param serializer The serializer used to encode/decode protobuf.
     * @param ref The reference to the document.
     * @param _fieldsProto The fields of the Firestore `Document` Protobuf backing
     * this document (or undefined if the document does not exist).
     * @param readTime The time when this result was read  (or undefined if
     * the document exists only locally).
     * @param createTime The time when the document was created if the result is a document, undefined otherwise.
     * @param updateTime The time when the document was last updated if the result is a document, undefined otherwise.
     */
    constructor(serializer, 
    /**
     * @beta
     * @internal
     * @private
     **/
    _fieldsProto, ref, readTime, createTime, updateTime) {
        this._fieldsProto = _fieldsProto;
        this._ref = ref;
        this._serializer = serializer;
        this._executionTime = readTime;
        this._createTime = createTime;
        this._updateTime = updateTime;
    }
    /**
     * @beta
     * The reference of the document, if it is a document; otherwise `undefined`.
     */
    get ref() {
        return this._ref;
    }
    /**
     * @beta
     * The ID of the document for which this PipelineResult contains data, if it is a document; otherwise `undefined`.
     *
     * @type {string}
     * @readonly
     *
     */
    get id() {
        return this._ref?.id;
    }
    /**
     * @beta
     * The time the document was created. Undefined if this result is not a document.
     *
     * @type {Timestamp|undefined}
     * @readonly
     */
    get createTime() {
        return this._createTime;
    }
    /**
     * @beta
     * The time the document was last updated (at the time the snapshot was
     * generated). Undefined if this result is not a document.
     *
     * @type {Timestamp|undefined}
     * @readonly
     */
    get updateTime() {
        return this._updateTime;
    }
    /**
     * @beta
     * Retrieves all fields in the result as an object.
     *
     * @returns {T} An object containing all fields in the document.
     *
     * @example
     * ```
     * let p = firestore.pipeline().collection('col');
     *
     * p.execute().then(results => {
     *   let data = results[0].data();
     *   console.log(`Retrieved data: ${JSON.stringify(data)}`);
     * });
     * ```
     */
    data() {
        const fields = this._fieldsProto;
        const obj = {};
        for (const prop of Object.keys(fields)) {
            obj[prop] = this._serializer.decodeValue(fields[prop]);
        }
        return obj;
    }
    /**
     * @beta
     * Retrieves the field specified by `field`.
     *
     * @param {string|FieldPath} fieldPath The field path
     * (e.g. 'foo' or 'foo.bar') to a specific field.
     * @returns {*} The data at the specified field location or undefined if no
     * such field exists.
     *
     * @example
     * ```
     * let p = firestore.pipeline().collection('col');
     *
     * p.execute().then(results => {
     *   let field = results[0].get('a.b');
     *   console.log(`Retrieved field value: ${field}`);
     * });
     * ```
     */
    // We deliberately use `any` in the external API to not impose type-checking
    // on end users.
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    get(fieldPath) {
        (0, path_1.validateFieldPath)('field', fieldPath);
        const protoField = this.protoField(fieldPath);
        if (protoField === undefined) {
            return undefined;
        }
        return this._serializer.decodeValue(protoField);
    }
    /**
     * @beta
     * Retrieves the field specified by 'fieldPath' in its Protobuf JS
     * representation.
     *
     * @private
     * @internal
     * @param field The path (e.g. 'foo' or 'foo.bar') to a specific field.
     * @returns The Protobuf-encoded data at the specified field location or
     * undefined if no such field exists.
     */
    protoField(field) {
        let fields = this._fieldsProto;
        if (fields === undefined) {
            return undefined;
        }
        const components = index_1.FieldPath.fromArgument(field).toArray();
        while (components.length > 1) {
            fields = fields[components.shift()];
            if (!fields || !fields.mapValue) {
                return undefined;
            }
            fields = fields.mapValue.fields;
        }
        return fields[components[0]];
    }
    /**
     * @beta
     * Returns true if the document's data and path in this `PipelineResult` is
     * equal to the provided value.
     *
     * @param {*} other The value to compare against.
     * @returns {boolean} true if this `PipelineResult` is equal to the provided
     * value.
     */
    isEqual(other) {
        return (this === other ||
            ((0, util_1.isOptionalEqual)(this.ref, other.ref) &&
                deepEqual(this._fieldsProto, other._fieldsProto)));
    }
}
exports.PipelineResult = PipelineResult;
//# sourceMappingURL=pipelines.js.map